<DynamicFolderExport>
    <Name>Dynamic Folder Export</Name>
    <Objects>
        <DynamicFolderExportObject>
            <Type>DynamicFolder</Type>
            <Name>Pleasant Password (Python)</Name>
            <Description>This Dynamic Folder sample for Pleasant Password Server supports Dynamic Credentials, Multi-Factor-Authentication (MFA), APIv4 and APIv5.</Description>
            <Notes><![CDATA[<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<style type="text/css">.cs2654AE3A{text-align:left;text-indent:0pt;margin:0pt 0pt 0pt 0pt}
			.csE8BD414E{color:#000000;background-color:transparent;font-family:'Times New Roman';font-size:18pt;font-weight:bold;font-style:normal;}
			.csAD7A2888{text-align:left;text-indent:0pt;margin:12pt 0pt 12pt 0pt}
			.cs102784{color:#000000;background-color:transparent;font-family:'Times New Roman';font-size:12pt;font-weight:bold;font-style:normal;}
			.cs23FB0664{color:#000000;background-color:transparent;font-family:'Times New Roman';font-size:12pt;font-weight:normal;font-style:normal;}
			.cs17BF9202{color:#000000;background-color:transparent;font-family:'Times New Roman';font-size:13.5pt;font-weight:bold;font-style:normal;}
			.cs37063928{text-align:left;margin:0pt 0pt 0pt 0pt;list-style-type:disc;color:#000000;background-color:transparent;font-family:Arial;font-size:12pt;font-weight:normal;font-style:normal}
			.csD95D4409{text-align:left;margin:0pt 0pt 0pt 0pt;list-style-type:circle;color:#000000;background-color:transparent;font-family:'Courier New';font-size:12pt;font-weight:normal;font-style:normal}
</style>
<h2><span style="font-kerning: none"><b>Dynamic Folder sample for Pleasant Password Server</b></span></h2>

<p><strong>Version</strong>: 1.2.3<br />
<strong>Authors</strong>: Royal Apps,&nbsp;Petr Stepan</p>

<p>This Dynamic Folder sample for Pleasant Password Server supports Dynamic Credentials,&nbsp;Multi-Factor-Authentication (MFA), APIv4 and&nbsp;APIv5. Python 2 and Python 3 are supported.</p>

<h3><strong>Requirements</strong></h3>

<ul>
	<li>Python Module: __future__</li>
	<li>Python Module: sys</li>
	<li>Python Module: functools</li>
	<li>Python Module: json</li>
	<li>Python Module: requests</li>
	<li>Python Module: urllib3</li>
	<li>Python Module: tkinter</li>
</ul>

<h3><strong>Setup</strong></h3>

<ul>
	<li>Enter your &quot;Server URL&quot; in the &quot;Custom Properties&quot; section (without trailing slash).</li>
	<li>Enter your &quot;API Version&quot; in the &quot;Custom Properties&quot; section (defaults to APIv5).
	<ul>
		<li>Supported version: APIv4, APIv5</li>
	</ul>
	</li>
	<li>Choose whether you want to omit domain name from credentials in the &quot;Custom Properties&quot; section.</li>
	<li>Enter or assign your Pleasant Password Server credentials.</li>
</ul>
]]></Notes>
            <CustomProperties>
                <CustomProperty>
                    <Name>Server URL</Name>
                    <Type>URL</Type>
                    <Value>TODO</Value>
                </CustomProperty>
                <CustomProperty>
                    <Name>API Version</Name>
                    <Type>Text</Type>
                    <Value>5</Value>
                </CustomProperty>
                <CustomProperty>
                    <Name>Omit Domain</Name>
                    <Type>YesNo</Type>
                    <Value>False</Value>
                </CustomProperty>
            </CustomProperties>
            <ScriptInterpreter>python</ScriptInterpreter>
            <Script><![CDATA[from __future__ import print_function
import sys
from functools import partial
import json
import requests
import urllib3

try:
	# for Python2
	from Tkinter import * 
except ImportError:
	# for Python3
	from tkinter import *

class TakeInput(object):
	def __init__(self, request_message):
		self.root = Tk()

		title = ""

		if request_message:
			title = request_message
			
			if title.endswith(":"):
				title = title[:-1]

		self.root.title(title)

		# Do not allow the user to resize the window
		self.root.resizable(False, False)
		
		self.string = ""

		self.frame = Frame(self.root)

		self.acceptInput(request_message)
		self.frame.pack(padx=17, pady=17)

	def acceptInput(self, request_message):
		r = self.frame

		icon = Label(r, text="", image="::tk::icons::question")
		icon.grid(row=0, column=0, rowspan=2, sticky="w")

		label = Label(r, text=request_message)
		label.grid(row=0, column=1, padx=(9, 0), sticky="nw")
		
		self.e = Entry(r, text='Name')
		self.e.grid(row=1, column=1, padx=(13, 0), sticky="nw")
		self.e.configure(width=30)
		self.e.focus_set()

		b = Button(r, text='        OK        ', command=self.gettext)
		b.grid(row=2, column=1, sticky="ne", pady=(10, 0))
		
		self.root.bind('<Return>', self.gettext)

	def gettext(self, event=None):
		self.string = self.e.get()
		self.root.destroy()

	def getString(self):
		return self.string
	
	def configureWindowGeometry(self):
		# Get the window size
		window_width = self.root.winfo_width()
		window_height = self.root.winfo_height()

		# Get the screen size
		screen_width = self.root.winfo_screenwidth()
		screen_height = self.root.winfo_screenheight()

		# Get the window position from the top dynamically as well as position from left or right as follows
		position_top = int((screen_height / 2) - (window_height / 2))
		position_right = int((screen_width / 2) - (window_width / 2))

		# Shift up by a couple of pixels to account for the title bar
		position_top -= 30

		# This will center the window
		self.root.geometry(str(window_width) + "x" + str(window_height) + "+" + str(position_right) + "+" + str(position_top))

	def waitForInput(self):
		self.root.lift()

		self.root.attributes('-topmost', True)
		self.root.after_idle(self.root.attributes, '-topmost', False)

		# Ensure that layout is ready
		self.root.update_idletasks()

		self.configureWindowGeometry()

		self.root.mainloop()

def show_prompt(request_message):
	msg_box = TakeInput(request_message)

	# loop until the user makes a decision and the window is destroyed
	msg_box.waitForInput()

	return msg_box.getString()


def convert_notes_to_html(notes):
	if notes is None:
		return ""
	else:
		return notes.replace("\r\n", "<br />").replace("\r", "<br />").replace("\n", "<br />")


def create_credential(url, headers, credential):
	credential_id = credential["Id"]
	credential_name = credential["Name"]
	credential_url = credential["Url"]
	credential_username = credential["Username"]
	credential_notes = convert_notes_to_html(credential["Notes"])
	credential_custom_properties = credential["CustomUserFields"]
	credential_color = ""

	credential_custom_app_fields = credential.get("CustomApplicationFields", None)

	if credential_custom_app_fields is not None:
		credential_color = credential_custom_app_fields.get("ForegroundColor", "")

	credential_description = ""

	for tag in credential["Tags"]:
		tag_name = tag["Name"]
		credential_description += tag_name + ", "

	if credential_description.endswith(", "):
		credential_description = credential_description[:len(credential_description) - 2]

	credential = {
		"Type": "DynamicCredential",
		"ID": credential_id,
		"Name": credential_name,
		"Color": credential_color,
		"URL": credential_url,
		"Username": credential_username,
		"Notes": credential_notes,
		"Description": credential_description,
		"CustomProperties": credential_custom_properties
	}

	return credential


def create_credential_group(url, headers, credential_group):
	folder_id = credential_group["Id"]
	folder_name = credential_group["Name"]
	folder_notes = convert_notes_to_html(credential_group["Notes"])

	folder_objects = []

	for sub_credential_group in credential_group["Children"]:
		folder_object = create_credential_group(url, headers, sub_credential_group)
		folder_objects.append(folder_object)

	for credential in credential_group["Credentials"]:
		credential_object = create_credential(url, headers, credential)
		folder_objects.append(credential_object)

	folder = {
		"Type":	 "Folder",
		"ID":	   folder_id,
		"Name":	 folder_name,
		"Notes":	folder_notes,
		"Objects":  folder_objects
	}

	# No need to create the root folder
	if credential_group["ParentId"] == "00000000-0000-0000-0000-000000000000" and folder_name == "Root":
		return folder_objects

	return folder

def call_token_endpoint(url, body, otp_headers):
	printError = partial(print, file=sys.stderr) # python2 compatibility
	try:
		token_json = requests.post(url + "/OAuth2/Token", data=body, verify=False, headers=otp_headers)
		token_json.raise_for_status()
		return token_json
	except requests.exceptions.HTTPError as e:
		if "X-Pleasant-OTP" in token_json.headers and token_json.headers["X-Pleasant-OTP"] == "required":
			return token_json
		
		if token_json.status_code == 400:
			printError("HTTP Error 400: Bad Request - could be a redundant domain name, try to omit it. Details: ",e)
		else:
			printError("HTTP Error: ",e)
		sys.exit(1)
	except requests.exceptions.ConnectionError:
		printError("Connection failed.")
		sys.exit(1)
	except requests.exceptions.Timeout:
		printError("Connection timeout.")
		sys.exit(1)
	except requests.exceptions.RequestException as e:
		printError("An unknown connection error occurred. Details: ",e)
		sys.exit(1)

def get_api_string(version):
	api_string_list = {
		"4": "/api/v4/rest/credentialgroup/",
		"5": "/api/v5/rest/folders/"
	}
	api_string = api_string_list.get(version, "/api/v5/rest/folders/")

	return api_string

def get_entries(url, username, password):
	printError = partial(print, file=sys.stderr) # python2 compatibility
	urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

	token_params = {
		"grant_type": "password",
		"username": username,
		"password": password
	}

	token_json = call_token_endpoint(url, token_params, None)

	if not token_json.ok:
		if "X-Pleasant-OTP" in token_json.headers and token_json.headers["X-Pleasant-OTP"] == "required":
			otp_provider = token_json.headers["X-Pleasant-OTP-Provider"]

			otp_token = show_prompt("Enter your OTP for MFA (" + otp_provider + "):")

			if not otp_token:
				printError("No token for MFA provided")
				return ""

			otp_headers = {
				"X-Pleasant-OTP-Provider": otp_provider,
				"X-Pleasant-OTP": otp_token
			}

			token_json = call_token_endpoint(url, token_params, otp_headers)
		else:
			printError("An unknown error occurred (could be redundant domain name, try to omit it).")
			return ""

	token = json.loads(token_json.content)["access_token"]

	headers = {
		"Accept": "application/json",
		"Authorization": token
	}
	
	api_string = get_api_string(r"$CustomProperty.APIVersion$")
	
	credential_groups_json = requests.get(url + api_string, headers=headers, verify=False)
	credential_groups = json.loads(credential_groups_json.content)

	store_objects = []

	if credential_groups is not list:
		credential_groups = [credential_groups]

	for credentialGroup in credential_groups:
		folder = create_credential_group(url, headers, credentialGroup)
		store_objects.extend(folder)

	store = {
		"Objects": store_objects
	}

	store_json = json.dumps(store)

	return store_json

if r"$CustomProperty.OmitDomain$" == "Yes":
	print(get_entries(r"$CustomProperty.ServerURL$", r"$EffectiveUsernameWithoutDomain$", r"$EffectivePassword$"))
else:
	print(get_entries(r"$CustomProperty.ServerURL$", r"$EffectiveUsername$", r"$EffectivePassword$"))]]></Script>
            <DynamicCredentialScriptInterpreter>python</DynamicCredentialScriptInterpreter>
            <DynamicCredentialScript><![CDATA[from __future__ import print_function
import sys
from functools import partial
import json
import requests
import urllib3

try:
	# for Python2
	from Tkinter import * 
except ImportError:
	# for Python3
	from tkinter import *

class TakeInput(object):
	def __init__(self, request_message):
		self.root = Tk()

		title = ""

		if request_message:
			title = request_message
			
			if title.endswith(":"):
				title = title[:-1]

		self.root.title(title)

		# Do not allow the user to resize the window
		self.root.resizable(False, False)
		
		self.string = ""

		self.frame = Frame(self.root)

		self.acceptInput(request_message)
		self.frame.pack(padx=17, pady=17)

	def acceptInput(self, request_message):
		r = self.frame

		icon = Label(r, text="", image="::tk::icons::question")
		icon.grid(row=0, column=0, rowspan=2, sticky="w")

		label = Label(r, text=request_message)
		label.grid(row=0, column=1, padx=(9, 0), sticky="nw")
		
		self.e = Entry(r, text='Name')
		self.e.grid(row=1, column=1, padx=(13, 0), sticky="nw")
		self.e.configure(width=30)
		self.e.focus_set()

		b = Button(r, text='        OK        ', command=self.gettext)
		b.grid(row=2, column=1, sticky="ne", pady=(10, 0))
		
		self.root.bind('<Return>', self.gettext)

	def gettext(self, event=None):
		self.string = self.e.get()
		self.root.destroy()

	def getString(self):
		return self.string
	
	def configureWindowGeometry(self):
		# Get the window size
		window_width = self.root.winfo_width()
		window_height = self.root.winfo_height()

		# Get the screen size
		screen_width = self.root.winfo_screenwidth()
		screen_height = self.root.winfo_screenheight()

		# Get the window position from the top dynamically as well as position from left or right as follows
		position_top = int((screen_height / 2) - (window_height / 2))
		position_right = int((screen_width / 2) - (window_width / 2))

		# Shift up by a couple of pixels to account for the title bar
		position_top -= 30

		# This will center the window
		self.root.geometry(str(window_width) + "x" + str(window_height) + "+" + str(position_right) + "+" + str(position_top))

	def waitForInput(self):
		self.root.lift()

		self.root.attributes('-topmost', True)
		self.root.after_idle(self.root.attributes, '-topmost', False)

		# Ensure that layout is ready
		self.root.update_idletasks()

		self.configureWindowGeometry()

		self.root.mainloop()

def show_prompt(request_message):
	msg_box = TakeInput(request_message)

	# loop until the user makes a decision and the window is destroyed
	msg_box.waitForInput()

	return msg_box.getString()


def call_token_endpoint(url, body, otp_headers):
	printError = partial(print, file=sys.stderr) # python2 compatibility
	try:
		token_json = requests.post(url + "/OAuth2/Token", data=body, verify=False, headers=otp_headers)
		token_json.raise_for_status()
		return token_json
	except requests.exceptions.HTTPError as e:
		if "X-Pleasant-OTP" in token_json.headers and token_json.headers["X-Pleasant-OTP"] == "required":
			return token_json
		
		if token_json.status_code == 400:
			printError("HTTP Error 400: Bad Request - could be a redundant domain name, try to omit it. Details: ",e)
		else:
			printError("HTTP Error: ",e)
		sys.exit(1)
	except requests.exceptions.ConnectionError:
		printError("Connection failed.")
		sys.exit(1)
	except requests.exceptions.Timeout:
		printError("Connection timeout.")
		sys.exit(1)
	except requests.exceptions.RequestException as e:
		printError("An unknown connection error occurred. Details: ",e)
		sys.exit(1)

def get_api_string(version):
	api_string_list = {
		"4": "/api/v4/rest/credential/",
		"5": "/api/v5/rest/entries/"
	}
	api_string = api_string_list.get(version, "/api/v5/rest/entries")

	return api_string

def get_dynamic_credential(url, username, password, credential_id):
	printError = partial(print, file=sys.stderr) # python2 compatibility
	urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

	token_params = {
		"grant_type": "password",
		"username": username,
		"password": password
	}

	token_json = call_token_endpoint(url, token_params, None)

	if not token_json.ok:
		if "X-Pleasant-OTP" in token_json.headers and token_json.headers["X-Pleasant-OTP"] == "required":
			otp_provider = token_json.headers["X-Pleasant-OTP-Provider"]

			otp_token = show_prompt("Enter your OTP for MFA (" + otp_provider + "):")

			if not otp_token:
				printError("No token for MFA provided")
				return ""

			otp_headers = {
				"X-Pleasant-OTP-Provider": otp_provider,
				"X-Pleasant-OTP": otp_token
			}

			token_json = call_token_endpoint(url, token_params, otp_headers)
		else:
			printError("An unknown error occurred (could be redundant domain name, try to omit it).")
			return ""

	token = json.loads(token_json.content)["access_token"]

	headers = {
		"Accept": "application/json",
		"Authorization": token
	}

	api_string = get_api_string(r"$CustomProperty.APIVersion$")
	
	credential_password_json = requests.get(url + api_string + credential_id + "/password", headers=headers, verify=False)
	credential_password = json.loads(credential_password_json.content)

	credential = {
		"Password": credential_password
	}

	credential_json = json.dumps(credential)

	return credential_json

if r"$CustomProperty.OmitDomain$" == "Yes":
	print(get_dynamic_credential(r"$CustomProperty.ServerURL$", r"$EffectiveUsernameWithoutDomain$", r"$EffectivePassword$", r"$DynamicCredential.EffectiveID$"))
else:
	print(get_dynamic_credential(r"$CustomProperty.ServerURL$", r"$EffectiveUsername$", r"$EffectivePassword$", r"$DynamicCredential.EffectiveID$"))]]></DynamicCredentialScript>
        </DynamicFolderExportObject>
    </Objects>
</DynamicFolderExport>