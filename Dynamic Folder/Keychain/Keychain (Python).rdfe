{
  "Name": "Dynamic Folder Export",
  "Objects": [
    {
      "Notes": "<h2>Keychain (Python)</h2>\n\n<p>Version: 1.0<br />\nAuthor: Royal Apps</p>\n\n<h3>Description</h3>\n\n<p>This script dynamically retrieves usernames and passwords from the macOS Keychain. You provide the names of the keychain items as a semicolon separated list in the custom properties section. When reloading the dynamic folder, a dynamic credential object&nbsp;will be created for each provided keychain item. When opening a connection that uses one of the dynamic credentials, the username and password will be requested from the keychain.</p>\n\n<h3>Configuration</h3>\n\n<ul>\n\t<li>Add the names of keychain items you want to retrieve as a semicolon separated list to the &quot;<strong>Keychain Item Names</strong>&quot; custom property.</li>\n</ul>\n\n<h3>Prerequisits</h3>\n\n<ul>\n\t<li><strong>Python 3</strong> must be installed and configured.</li>\n</ul>\n",
      "Script": "import sys\nimport subprocess\nimport json\nimport re\nimport binascii\n\ndef print_to_stderr(text: str, should_exit: bool):\n\tprint(text, file=sys.stderr)\n\n\tif should_exit:\n\t\texit(1)\n\ndef hex_to_string(hex: str) -> str:\n\tunhexified_string = str(binascii.unhexlify(hex), 'utf-8')\n\n\treturn unhexified_string\n\ndef run_subprocess(command: str):\n\treturn subprocess.run(command, shell=True, check=True, capture_output=True)\n\ndef get_keychain_item(item_name: str, include_password: bool) -> tuple[str, str]:\n\tkc_output = None\n\n\ttry:\n\t\tkc_command_generic = f\"security find-generic-password -l '{item_name}'\"\n\n\t\tif include_password:\n\t\t\tkc_command_generic += ' -g'\n\n\t\tkc_output = run_subprocess(kc_command_generic)\n\texcept subprocess.CalledProcessError as e:\n\t\ttry:\n\t\t\tkc_command_internet = f\"security find-internet-password -l '{item_name}'\"\n\n\t\t\tif include_password:\n\t\t\t\tkc_command_internet += ' -g'\n\n\t\t\tkc_output = run_subprocess(kc_command_internet)\n\t\texcept subprocess.CalledProcessError as e:\n\t\t\tkc_error = e.stderr.decode().strip()\n\n\t\t\twrapped_kc_error = f'An error occurred while retrieving an item named \"{item_name}\" from the keychain.\\n\\n{kc_error}'\n\n\t\t\tprint_to_stderr(wrapped_kc_error, True)\n\n\tif kc_output is None:\n\t\tprint_to_stderr(\"No output\", True)\n\t\n\tkc_standard_output = kc_output.stdout.decode()\n\tkc_error_output = ''\n\n\tif kc_output.stderr is not None:\n\t\tkc_error_output = kc_output.stderr.decode()\n\n\treturn (kc_standard_output, kc_error_output)\n\ndef get_keychain_detail(kc_details_output: str, key: str) -> str:\n\tkc_ascii_match = re.search(f'.*?\\\"{key}\\\".*?=\\\"(.*)\\\"', kc_details_output)\n\n\tif kc_ascii_match is not None:\n\t\t# Extract ASCII Value\n\t\tkc_value = kc_ascii_match.group(1)\n\n\t\treturn kc_value\n\t\n\tkc_hex_match = re.search(f'.*?\\\"{key}\\\".*?=0x(.*?)\\s', kc_details_output)\n\n\tif kc_hex_match is not None:\n\t\t# Extract Non-ASCII Value\n\t\tkc_value = hex_to_string(kc_hex_match.group(1))\n\n\t\treturn kc_value\n\t\n\treturn None\n\ndef get_keychain_comment(kc_details_output: str) -> str:\n\tkc_value = get_keychain_detail(kc_details_output, \"icmt\")\n\n\tif kc_value == \"default\":\n\t\tkc_value = None\n\n\treturn kc_value\n\ndef get_keychain_protocol(kc_details_output: str) -> str:\n\tkc_value = get_keychain_detail(kc_details_output, \"ptcl\")\n\n\treturn kc_value\n\ndef get_keychain_server(kc_details_output: str) -> str:\n\tkc_value = get_keychain_detail(kc_details_output, \"srvr\")\n\n\treturn kc_value\n\ndef get_keychain_path(kc_details_output: str) -> str:\n\tkc_value = get_keychain_detail(kc_details_output, \"path\")\n\n\treturn kc_value\n\ndef get_keychain_url(kc_details_output: str) -> str:\n\tkc_protocol = get_keychain_protocol(kc_details_output)\n\tkc_server = get_keychain_server(kc_details_output)\n\tkc_path = get_keychain_path(kc_details_output)\n\n\tkc_url = None\n\n\tif kc_protocol is not None:\n\t\tif kc_protocol == \"htps\":\n\t\t\tkc_url = \"https://\"\n\t\telif kc_protocol == \"http\":\n\t\t\tkc_url = \"http://\"\n\n\tif kc_server is not None:\n\t\tif kc_url is None:\n\t\t\tkc_url = \"\"\n\n\t\tkc_url += kc_server\n\n\tif kc_url is None:\n\t\treturn None\n\n\tif kc_path is not None:\n\t\tkc_url += kc_path\n\n\treturn kc_url\n\ndef get_keychain_account(kc_details_output: str) -> str:\n\tkc_value = get_keychain_detail(kc_details_output, \"acct\")\n\n\tif kc_value == None:\n\t\tprint_to_stderr(\"Username was not found in Keychain output.\", True)\n\t\n\treturn kc_value\n\ndef get_dynamic_credential(name: str, id: str, username: str, description: str, url: str) -> object:\n\tdynamic_credential = {\n\t\t\"Type\": \"DynamicCredential\",\n\t\t\"ID\": id,\n\t\t\"Name\": name\n\t}\n\n\tif username is not None:\n\t\tdynamic_credential[\"Username\"] = username\n\t\n\tif description is not None:\n\t\tdynamic_credential[\"Description\"] = description\n\n\tif url is not None:\n\t\tdynamic_credential[\"URL\"] = url\n\n\treturn dynamic_credential\n\ndef get_dynamic_credentials(names_string: str) -> list[object]:\n\tnames = list(filter(None, names_string.split(';')))\n\tdynamic_credentials = [ ]\n\n\tfor name in names:\n\t\tkc_output = get_keychain_item(name, False)\n\n\t\tif kc_output is None or kc_output[0] is None:\n\t\t\tprint_to_stderr(f'The item \"{name}\" was not found in the Keychain.', True)\n\n\t\tusername = get_keychain_account(kc_output[0])\n\t\tcomment = get_keychain_comment(kc_output[0])\n\n\t\tif comment is not None:\n\t\t\tcomment = comment.replace('\\r\\n', '\\n').replace('\\r', '\\n').replace('\\n', ' ')\n\n\t\turl = get_keychain_url(kc_output[0])\n\t\t\n\t\tdynamic_credential = get_dynamic_credential(name, name, username, comment, url)\n\n\t\tdynamic_credentials.append(dynamic_credential)\n\t\n\treturn dynamic_credentials\n\ndef get_store(objects: list[object]) -> object:\n\treturn {\n\t\t\"Objects\": objects\n\t}\n\nkc_item_names=r'$CustomProperty.KeychainItemNames$'\n\ndynamic_credentials = get_dynamic_credentials(kc_item_names)\nstore = get_store(dynamic_credentials)\nprint(json.dumps(store))",
      "DynamicCredentialScript": "import sys\nimport subprocess\nimport json\nimport re\nimport binascii\n\ndef print_to_stderr(text: str, should_exit: bool):\n\tprint(text, file=sys.stderr)\n\n\tif should_exit:\n\t\texit(1)\n\ndef hex_to_string(hex: str) -> str:\n\tunhexified_string = str(binascii.unhexlify(hex), 'utf-8')\n\n\treturn unhexified_string\n\ndef run_subprocess(command: str):\n\treturn subprocess.run(command, shell=True, check=True, capture_output=True)\n\ndef get_keychain_item(item_name: str, include_password: bool) -> tuple[str, str]:\n\tkc_output = None\n\n\ttry:\n\t\tkc_command_generic = f\"security find-generic-password -l '{item_name}'\"\n\n\t\tif include_password:\n\t\t\tkc_command_generic += ' -g'\n\n\t\tkc_output = run_subprocess(kc_command_generic)\n\texcept subprocess.CalledProcessError as e:\n\t\ttry:\n\t\t\tkc_command_internet = f\"security find-internet-password -l '{item_name}'\"\n\n\t\t\tif include_password:\n\t\t\t\tkc_command_internet += ' -g'\n\n\t\t\tkc_output = run_subprocess(kc_command_internet)\n\t\texcept subprocess.CalledProcessError as e:\n\t\t\tkc_error = e.stderr.decode().strip()\n\n\t\t\twrapped_kc_error = f'An error occurred while retrieving an item named \"{item_name}\" from the keychain.\\n\\n{kc_error}'\n\n\t\t\tprint_to_stderr(wrapped_kc_error, True)\n\n\tif kc_output is None:\n\t\tprint_to_stderr(\"No output\", True)\n\t\n\tkc_standard_output = kc_output.stdout.decode()\n\tkc_error_output = ''\n\n\tif kc_output.stderr is not None:\n\t\tkc_error_output = kc_output.stderr.decode()\n\n\treturn (kc_standard_output, kc_error_output)\n\ndef get_keychain_detail(kc_details_output: str, key: str) -> str:\n\tkc_ascii_match = re.search(f'.*?\\\"{key}\\\".*?=\\\"(.*)\\\"', kc_details_output)\n\n\tif kc_ascii_match is not None:\n\t\t# Extract ASCII Value\n\t\tkc_value = kc_ascii_match.group(1)\n\n\t\treturn kc_value\n\t\n\tkc_hex_match = re.search(f'.*?\\\"{key}\\\".*?=0x(.*?)\\s', kc_details_output)\n\n\tif kc_hex_match is not None:\n\t\t# Extract Non-ASCII Value\n\t\tkc_value = hex_to_string(kc_hex_match.group(1))\n\n\t\treturn kc_value\n\t\n\treturn None\n\ndef get_keychain_comment(kc_details_output: str) -> str:\n\tkc_value = get_keychain_detail(kc_details_output, \"icmt\")\n\n\tif kc_value == \"default\":\n\t\tkc_value = None\n\n\treturn kc_value\n\ndef get_keychain_protocol(kc_details_output: str) -> str:\n\tkc_value = get_keychain_detail(kc_details_output, \"ptcl\")\n\n\treturn kc_value\n\ndef get_keychain_server(kc_details_output: str) -> str:\n\tkc_value = get_keychain_detail(kc_details_output, \"srvr\")\n\n\treturn kc_value\n\ndef get_keychain_path(kc_details_output: str) -> str:\n\tkc_value = get_keychain_detail(kc_details_output, \"path\")\n\n\treturn kc_value\n\ndef get_keychain_url(kc_details_output: str) -> str:\n\tkc_protocol = get_keychain_protocol(kc_details_output)\n\tkc_server = get_keychain_server(kc_details_output)\n\tkc_path = get_keychain_path(kc_details_output)\n\n\tkc_url = None\n\n\tif kc_protocol is not None:\n\t\tif kc_protocol == \"htps\":\n\t\t\tkc_url = \"https://\"\n\t\telif kc_protocol == \"http\":\n\t\t\tkc_url = \"http://\"\n\n\tif kc_server is not None:\n\t\tif kc_url is None:\n\t\t\tkc_url = \"\"\n\n\t\tkc_url += kc_server\n\n\tif kc_url is None:\n\t\treturn None\n\n\tif kc_path is not None:\n\t\tkc_url += kc_path\n\n\treturn kc_url\n\ndef get_keychain_account(kc_details_output: str) -> str:\n\tkc_value = get_keychain_detail(kc_details_output, \"acct\")\n\n\tif kc_value == None:\n\t\tprint_to_stderr(\"Username was not found in Keychain output.\", True)\n\t\n\treturn kc_value\n\ndef get_keychain_password(kc_password_output: str) -> str:\n\tkc_password_match = re.search('^password:\\s(.*)', kc_password_output)\n\n\tif kc_password_match is None:\n\t\tprint_to_stderr(\"Password was not found\", True)\n\n\tkc_password_string = kc_password_match.group(1)\n\n\tkc_password_ascii_match = re.search('^\\\"(.*)\\\"$', kc_password_string)\n\n\tkc_password = \"\"\n\n\tif kc_password_ascii_match is not None:\n\t\t# Extract ASCII Password\n\t\tkc_password = kc_password_ascii_match.group(1)\n\telse:\n\t\t# Extract Non-ASCII Password\n\t\tkc_password_unicode_match = re.search('^0x(.*?)\\s+?', kc_password_string)\n\n\t\tif kc_password_unicode_match is None:\n\t\t\tprint_to_stderr(\"Password was not found\", True)\n\t\t\n\t\tkc_password_hex = kc_password_unicode_match.group(1)\n\t\tkc_password = hex_to_string(kc_password_hex)\n\t\n\treturn kc_password\n\ndef get_username_password(kc_item_name: str) -> tuple[str, str]:\n\tkc_output = get_keychain_item(kc_item_name, True)\n\n\tkc_account = get_keychain_account(kc_output[0])\n\tkc_password = get_keychain_password(kc_output[1])\n\n\treturn (kc_account, kc_password)\n\ndef get_dynamic_credential_content(username: str, password: str) -> object:\n\treturn {\n\t\t\"Username\": username,\n\t\t\"Password\": password\n\t}\n\nkc_item_name=r'$DynamicCredential.EffectiveID$'\nkc_username_password = get_username_password(kc_item_name)\ndynamic_credential_content = get_dynamic_credential_content(kc_username_password[0], kc_username_password[1])\n\nprint(json.dumps(dynamic_credential_content))",
      "Type": "DynamicFolder",
      "Name": "Keychain (Python)",
      "Description": "This script dynamically retrieves usernames and passwords from the macOS Keychain.",
      "CustomProperties": [
        {
          "Name": "Keychain Item Names",
          "Type": "Text",
          "Value": "TODO"
        }
      ],
      "ScriptInterpreter": "python",
      "DynamicCredentialScriptInterpreter": "python"
    }
  ]
}